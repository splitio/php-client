#!/usr/bin/env php
<?php
require_once __DIR__ . '/constants.php';
require __DIR__ . '/../vendor/autoload.php';

use SplitIO\Common\Di;
use SplitIO\Log\Logger;
use SplitIO\Log\Handler\Stdout;
use SplitIO\Log\Handler\Syslog;
use SplitIO\Client;
use SplitIO\Engine;
use SplitIO\Cache\Pool;
use SplitIO\Cache\SplitCache;
use SplitIO\Cache\SegmentCache;

bootstrap(is_array($argv) ? $argv : array());

function getOption($option, $key, $val, $argv)
{
    $optionLen = strlen($option);
    $return = null;

    if (0 === strpos($val, $option)) {
        if ($optionLen === strlen($val) && isset($argv[$key+1])) {
            $return = trim($argv[$key+1]);
        } else {
            $return = trim(substr($val, $optionLen+1));
        }
    }

    return $return;
}

function getServiceOptionsMatrix()
{
    /**
     * CONFIG_ARRAY_KEY => ['cli' => '--cli-param', 'ini' => 'key']
     */
    return [
        SPLITIO_CONFIG_FILE => ['cli' => '--config-file',
            'ini'       => null,
            'default'   => null,
            'help'      => "the path to your custom ini file"],

        SPLITIO_CONFIG_API_KEY => ['cli' => '--api-key',
            'ini'       => 'split.api-key',
            'default'   => 'localhost',
            'help'      => 'your environment API key'],

        SPLITIO_CONFIG_TIME_GAP => ['cli' => '--time-gap',
            'ini'       => 'split.time-gap',
            'default'   => '300', //Fetch Splits every 5 minutes
            'help'      => "the time gap, expressed in seconds, between the last server request and the next one"],

        //LOG
        SPLITIO_CONFIG_LOG_ADAPTER => ['cli' => '--log-adapter',
            'ini'       => 'log.adapter',
            'default'   => 'stdout',
            'help'      => 'the log adapter. Values: stdout|syslog',
            'title'     => 'Log:'],

        SPLITIO_CONFIG_LOG_LEVEL => ['cli' => '--log-level',
            'ini'       => 'log.level',
            'default'   => 'info',
            'help'      => 'the log level. Values: emergency|alert|critical|error|warning|notice|info|debug'],

        SPLITIO_CONFIG_LOG_CUSTOM => ['cli' => '--log-custom',
            'ini'       => 'log.custom',
            'default'   => null,
            'help'      => 'the path to your custom Logger implementation'],

        //CACHE
        SPLITIO_CONFIG_CACHE_TTL => ['cli' => '--cache-ttl',
            'ini'       => 'cache.ttl',
            'default'   => 518400,
            'help'      => 'the time to live of cache items',
            'title'     => 'Cache:'],

        SPLITIO_CONFIG_CACHE_ADAPTER => ['cli' => '--cache-adapter',
            'ini'       => 'cache.adapter',
            'default'   => 'filesystem',
            'help'      => 'the cache adapter provided by Split SDK. Values: filesystem|memcached|redis'],

        SPLITIO_CONFIG_CACHE_FILESYSTEM_PATH => ['cli' => '--cache-filesystem-path',
            'ini'       => 'cache.options.path',
            'default'   => '/tmp',
            'help'      => 'the cache directory to save the cache files'],

        SPLITIO_CONFIG_CACHE_REDIS_HOST => ['cli' => '--cache-redis-host',
            'ini'       => 'cache.redis.host',
            'default'   => 'localhost',
            'help'      => 'the cache server host address for Redis adapter'],

        SPLITIO_CONFIG_CACHE_REDIS_PORT => ['cli' => '--cache-redis-port',
            'ini'       => 'cache.redis.port',
            'default'   => 6379,
            'help'      => 'the cache server port number for Redis adapter'],

        SPLITIO_CONFIG_CACHE_MEMCACHED_SERVERS => ['cli' => '--cache-memcached-servers',
            'ini'       => 'cache.options.server',
            'default'   => 'localhost:11211',
            'help'      => 'a list of comma-separated values of "server:port" couple for Memcached adapter'],

        SPLITIO_CONFIG_CACHE_CUSTOM => ['cli' => '--cache-custom',
            'ini'       => 'cache.custom',
            'default'   => null,
            'help'      => 'the path to your custom Cache implementation'],

    ];
}

function bootstrap($options)
{
    //Display command line help
    $help = in_array('--help', $options);

    //run the script as a service (within loop)
    $asService = in_array('--service', $options);

    if ($help) {
        displayHelp();
        exit(0);
    }

    $cliSyntaxMap = getServiceOptionsMatrix();

    //Parsing the user cli parameters
    $cliOptions = [];
    foreach ($options as $key => $val) {
        foreach ($cliSyntaxMap as $cfgK => $cfgV) {
            if (0 === strpos($val, $cfgV['cli'])) {
                $opt = getOption($cfgV['cli'], $key, $val, $options);
                $cliOptions[$cfgK] = ($opt) ? $opt : null;
            }
        }
    }

    //Parsing the ini file parameters.
    $customConfigFile = (isset($cliOptions[SPLITIO_CONFIG_FILE])) ? $cliOptions[SPLITIO_CONFIG_FILE] : null;
    $iniOptions = readConfig($customConfigFile);
    if (!$iniOptions) {
        outError("The configuration file is missing");
        exit(1);
    }

    //Merging ini and cli parameters. cli has priority.
    $finalOptions = [];
    foreach ($cliSyntaxMap as $k => $v) {
        if (isset($cliOptions[$k])) {
            if ($k == SPLITIO_CONFIG_CACHE_MEMCACHED_SERVERS) {
                $memcached_servers = explode(",", $cliOptions[$k]);
                for ($i=0; $i < count($memcached_servers); $i++) {
                    $memcached_servers[$i] = explode(":", $memcached_servers[$i]);
                }
                $finalOptions[$k] = $memcached_servers;
            } else {
                $finalOptions[$k] = $cliOptions[$k];
            }
        } elseif (isset($iniOptions[$v['ini']])) {
            $finalOptions[$k] = $iniOptions[$v['ini']];
        } else {
            if (isset($iniOptions[$v['default']])) {
                $finalOptions[$k] = $iniOptions[$v['default']];
            }
        }
    }

    //Setting options in Di to use it cross app.
    Di::getInstance()->set(SPLIT_DI_CONFIG_KEY, $finalOptions);
    Di::getInstance()->setSplitSdkConfiguration(\SplitIO\Sdk\SdkConfig::loadFromCliService($finalOptions));

    if ($asService) {

        $seconds = (int) $finalOptions[SPLITIO_CONFIG_TIME_GAP];
        $micro = $seconds * 1000000;

        while (true) {

            runSplitService();
            usleep($micro);

        }
    } else {
        runSplitService();
    }


}

function readConfig($configFile = null)
{
    if ($configFile === null) {
        $configFile = __DIR__.'/splitio.ini';
    }
    $config = false;
    if (file_exists($configFile)) {
        $config = parse_ini_file($configFile, true);
    }

    return $config;
}

/**
 * displays the help
 */
function displayHelp()
{

    $logo = <<<EOF

       __      ____        _ _ _
      / /__   / ___| _ __ | (_) |_
     / / \ \  \___ \| '_ \| | | __|
     \ \  \ \  ___) | |_) | | | |_
      \_\ / / |____/| .__/|_|_|\__|
         /_/        |_|

EOF;

    out($logo, SPLIT_FG_LIGHT_BLUE);

    $hlp = <<<EOF

 Usage:
    splitio [OPTIONS]

 Options:
     --help                         display this help
     --service                      run the command on pulling mode (see: --time-gap)
EOF;
    out($hlp);

    $options = getServiceOptionsMatrix();
    foreach ($options as $opt) {
        if (isset($opt['title'])) {
            out(PHP_EOL."   ".$opt['title']);
        }
        $init_str = "     ".$opt['cli'];
        $str = $init_str;
        for ($i=0; $i < (36 - strlen($init_str)); $i++) {
            $str .= " ";
        }
        $str .= $opt['help'];
        out($str);
    }

    out(PHP_EOL);

}

function addCachePool()
{
    $sdkConfig = Di::getInstance()->getSplitSdkConfiguration();

    $cacheCustomFile = $sdkConfig->getCacheCustom();
    if ($cacheCustomFile !== null && file_exists($cacheCustomFile)) {

        require_once($cacheCustomFile);

    } else {

        switch ($sdkConfig->getCacheAdapter()) {
            case 'memcached':
                $adapter_config = [
                    'name' => 'memcached',
                    'options' => [
                        'servers' => $sdkConfig->getCacheMemcachedServers()
                    ]
                ];
                break;

            case 'redis':
                $adapter_config = [
                    'name' => 'redis',
                    'options' => [
                        'host' => $sdkConfig->getCacheRedisHost(),
                        'port' => $sdkConfig->getCacheRedisPort(),
                    ]
                ];
                break;

            case 'filesystem':
            default:
                $adapter_config = [
                    'name' => 'filesystem',
                    'options' => [
                        'path'=> $sdkConfig->getCacheFilesystemPath()
                    ]
                ];
                break;
        }

        Di::getInstance()->setCache(new Pool([ 'adapter' => $adapter_config ]));
    }
}

function addLogger()
{
    $sdkConfig = Di::getInstance()->getSplitSdkConfiguration();

    $logCustomFile = $sdkConfig->getLogCustom();
    if ($logCustomFile !== null && file_exists($logCustomFile)) {

        require_once($logCustomFile);

    } else {
        $logAdapter = null;

        switch ($sdkConfig->getLogAdapter()) {
            case 'syslog':
                $logAdapter = new Syslog();
                break;

            case 'stdout':
            default:
                $logAdapter = new Stdout();
                break;
        }

        Di::getInstance()->setLogger(new Logger($logAdapter, $sdkConfig->getLogLevel()));
    }
}

function runSplitService()
{
    $di = Di::getInstance();
    $sdkConfig = $di->getSplitSdkConfiguration();

    //Setting the log adapter
    addLogger();

    //Adding Cache on Di
    addCachePool();

    //Setting the Split Client to connect Split servers
    if ($di->getSplitClient() === null) {
        $di->setSplitClient(new Client(SPLITIO_URL, $sdkConfig->getApiKey()));
    }

    //Fetching the Splits changes
    getSplits();

    //Fetching the Segments changes
    getSegments();

    //@TODO Refresh cache TTL of all items.

}

function getSplits()
{
    $di = Di::getInstance();

    //Fetching the Splits changes
    $splitChanges = $di->getSplitClient()->getSplitChanges();
    $splits = $splitChanges['splits'];

    $splitCache = new SplitCache();

    if (!empty($splits)) {
        //Creating Split Grammar structures
        foreach ($splits as $split) {

            $di->getLogger()->debug($split);

            $splitName = $split['name'];
            $splitStatus = $split['status'];
            $splitKilled = (bool) $split['killed'];

            $splitConditions = $split['conditions'];

            foreach ($splitConditions as $condition) {
                foreach ($condition['matcherGroup']['matchers'] as $matcher) {

                    if ($matcher['matcherType'] == "IN_SEGMENT") {
                        //Register segment to retrieve Segment Data.
                        SegmentCache::registerSegment($matcher['userDefinedSegmentMatcherData']['segmentName']);
                    } elseif ($matcher['matcherType'] == "WHITELIST") {
                        //@TODO add whitelist members on RedisSet.
                    }
                }
            }

            if ($splitStatus == 'ACTIVE' && !$splitKilled) { //Update Cache

                $splitCache->addSplit($splitName, json_encode($split));

            } else { //Delete item from cache

                $splitCache->removeSplit($splitName);

            }
        }
    }

    $till = (isset($splitChanges['till'])) ? $splitChanges['till'] : -1;

    //Updating next since (till) value.
    if ($till != $splitCache->getChangeNumber()) {
        $splitCache->setChangeNumber($till);
    }
}

function getSegments()
{
    $registeredSegments = Di::getInstance()->getCache()->getItemsOnList(SegmentCache::getCacheKeyForRegisterSegments());

    if (is_array($registeredSegments) && !empty($registeredSegments)) {
        foreach ($registeredSegments as $segmentName) {
            Di::getInstance()->getSplitClient()->updateSegmentChanges($segmentName);
        }
    }
}

/*
function registerSegments(array $detectedSegments)
{
    $cache = Di::getInstance()->getCache();
    $registeredSegmentsItem = $cache->getItem(\SplitIO\getCacheKeyForRegisterSegments());
    $segments = $registeredSegmentsItem->get();

    if ($segments) {
        $arraySegments = json_decode($segments, true);
    } else {
        $arraySegments = [];
    }

    $segmentsToAdd = array_unique(array_merge($arraySegments, $detectedSegments));

    $registeredSegmentsItem->set(json_encode($segmentsToAdd));
    $registeredSegmentsItem->expiresAfter(Di::getInstance()->getSplitSdkConfiguration()->getCacheItemTtl());
    $cache->save($registeredSegmentsItem);

}
*/


/*
function __getSegments()
{
    $di = Di::getInstance();
    $cache = $di->getCache();

    $registeredSegmentsItem = $cache->getItem(\SplitIO\getCacheKeyForRegisterSegments());
    $segments = $registeredSegmentsItem->get();

    if ($segments !== null) {
        $arraySegments = json_decode($segments, true);

        foreach ($arraySegments as $segmentName) {
            Di::getInstance()->getSplitClient()->updateSegmentChanges($segmentName);
        }
    }
}
*/
function out($str, $fg = null, $bg = null)
{
    $outString = "";

    if ($fg !== null) {
        $outString .= "\033[" . $fg . "m";
    }

    if ($bg !== null) {
        $outString .= "\033[" . $bg . "m";
    }

    // Add string and end coloring
    $outString .=  $str . "\033[0m";

    echo $outString.PHP_EOL;
}

function outError($str)
{
    out($str, SPLIT_FG_WHITE, SPLIT_BG_RED);
}

function outInfo($str)
{
    out($str, SPLIT_FG_BROWN);
}

function outSuccess($str)
{
    out($str, SPLIT_FG_GREEN);
}

